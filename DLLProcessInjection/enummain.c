#include <stdio.h>
#include <Windows.h>
#include <tlhelp32.h>

// Get the target pid 
DWORD GetProcId(const char* procName)
{
	DWORD procID = 0; 
	// snapshot of processes
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); 

	// If the snapshot is not invalid
	if (hSnap != INVALID_HANDLE_VALUE)
	{
		PROCESSENTRY32 procEntry; 
		procEntry.dwSize = sizeof(PROCESSENTRY32);
		// procEntry recieves each process from the snapshot
		if (Process32First(hSnap, &procEntry))
		{
			do {
				// checks if the process name and target name match 
				if (_stricmp(procEntry.szExeFile, procName) == 0)
				{
					// if matched, process id is stored
					procID = procEntry.th32ProcessID; 
					break; 
				}
			} while (Process32Next(hSnap, &procEntry)); 
		}
	}
	CloseHandle(hSnap); 
	return procID; 
}

int main(int argc, char* argv[])
{
	if (argc < 2)
	{
		printf("File usage <filetype> : %s", argv[0]); 
		return -1; 
	}

	const char* dllPath = argv[1]; 
	const char* procName = "notepad.exe"; 

	DWORD procID = 0; 

	while (!procID)
	{
		procID = GetProcId(procName); 
		Sleep(30); 
	}

	HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, 0, procID); 

	if (hProc != INVALID_HANDLE_VALUE)
	{
		void* loc = VirtualAllocEx(hProc, 0, MAX_PATH, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); 
		if (loc)
		{
			WriteProcessMemory(hProc, loc, dllPath, strlen(dllPath) + 1, 0);
		} 

		HANDLE hThread = CreateRemoteThread(hProc, 0, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, loc, 0, 0); 

		if (hThread)
		{
			CloseHandle(hThread); 
		}


	}		

	if (hProc)
	{
		CloseHandle(hProc); 
	}


}